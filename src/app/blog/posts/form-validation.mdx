---
title: form validation with next.js, react 19, server actions, and zod
publishedAt: 2024-10-03
summary: form validation
---

validating forms is an essential part of web development. react 19 has a new feature called [useActionState](https://react.dev/reference/react/useActionState) that will simplify how we handle server side form validation. combine it with [zod](https://github.com/colinhacks/zod) and server actions, we can create a powerful form validation system.

## current state of making forms

before useActionState, we usually use a combination of useState to manage error state and [useFormStatus](https://react.dev/reference/react-dom/hooks/useFormStatus) to manage the pending state, although the latter is only available on react canary channel based its latest docs (as of oct 2, 2024).

here's an example with next.js and server actions:

```tsx
import { revalidatePath } from 'next/cache';

export default function Form() {
  async function createTodo(formData: FormData) {
    'use server';

    const rawFormData = {
      title: formData.get('title'),
      body: formData.get('body'),
    };

    await fetch('/api/todos', {
      method: 'POST',
      headers: {
        'Content-Type': 'application/json',
      },
      body: JSON.stringify(rawFormData),
    });

    revalidatePath('/todos');
  }

  return (
    <form action={createTodo}>
      <input name="title" type="text" />
      <input name="body" type="text" />
      <button type="submit">Submit</button>
    </form>
  );
}
```

now, let's add a pending state when the form is submitting with **useFormStatus**. this hook will return a **pending** boolean that we can use to modify the button for better user experience.

but we need to move the server action to a separate file to make it work.

```ts
// actions.ts
'use server';

import { revalidatePath } from 'next/cache';

export async function createTodo(formData: FormData) {
  const rawFormData = {
    title: formData.get('title'),
    body: formData.get('body'),
  };

  await fetch('/api/todos', {
    method: 'POST',
    headers: {
      'Content-Type': 'application/json',
    },
    body: JSON.stringify(rawFormData),
  });

  revalidatePath('/todos');
}
```

```tsx
// form.tsx
'use client';

import { createTodo } from '@/lib/actions';
import { useFormStatus } from 'react-dom';
import { revalidatePath } from 'next/cache';

export default function Form() {
  const { pending } = useFormStatus();

  return (
    <form action={createTodo}>
      <input name="title" type="text" />
      <input name="body" type="text" disabled={pending} />
      <button type="submit" disabled={pending}>
        {pending ? 'Submitting...' : 'Submit'}
      </button>
    </form>
  );
}
```

at this point you can just add html `required` attribute for a simple **client-side validation**.

```html
<input name="title" type="text" required />
<input name="body" type="text" required />
```

but what if you want to validate the form on the server? sometimes validating should be done both on the client **and** server to prevent malicious users from bypassing the client-side validation.

we can use **useState**, but now that the server action is on another file, we need to pass the error state back from the server action to the form component.

one way to do this is to return a success state from the server action.

```ts
'use server';

import { revalidatePath } from 'next/cache';

export async function createTodo(formData: FormData) {
  const rawFormData = {
    title: formData.get('title'),
    body: formData.get('body'),
  };

  try {
    const res = await fetch('/api/todos', {
      method: 'POST',
      headers: {
        'Content-Type': 'application/json',
      },
      body: JSON.stringify(rawFormData),
    });

    if (!res.ok) {
      throw new Error('Failed to create todo');
    }

    revalidatePath('/todos');
    return { success: true, message: 'Todo created successfully' };
  } catch (error) {
    if (error instanceof Error) {
      return { success: false, message: error.message };
    } else {
      return { success: false, message: 'An error occurred' };
    }
  }
}
```

now on the client component, we can use the success state to show the error message.

```tsx
'use client';

import { createTodo } from '@/lib/test';
import { useState } from 'react';
import { useFormStatus } from 'react-dom';

export default function Form() {
  const { pending } = useFormStatus();
  const [error, setError] = useState<string | null>(null);

  async function handleSubmit(formData: FormData) {
    const result = await createTodo(formData);

    if (!result.success) {
      setError(result.message);
    } else {
      setError(null);
    }
  }

  return (
    <form action={handleSubmit}>
      <input name="title" type="text" required />
      <input name="body" type="text" disabled={pending} required />
      <button type="submit" disabled={pending}>
        {pending ? 'Submitting...' : 'Submit'}
      </button>
      {error && <p>{error}</p>}
    </form>
  );
}
```

note that now we use a **handleSubmit** function to call the server action, and we set the error state based on the result.

this only validates the result of the form submission, not the indiviual fields. usually for better user experience and security, **we should also validate each field** before submitting the form. this is important, especially when working with multiple fields that has different constraints. for example, we may need to set the limit of the title to 50 characters, and the body to 500 characters.

now we have to validate each fields, define our constraints, and set the error state for each field manually using **if else statement** and **useState**. if you have multiple fields, this would be a bit cumbersome.

to make it a bit simple, we can skip manually defining our constraints and use a library called **zod** to define the form schema. this will make it easier to validate the form fields.

## using zod for form validation on the server

[zod](https://github.com/colinhacks/zod) is a schema definition library that can be used to validate data.

first, let's define our schema for the todo form, we will add this on the server action file.

```ts
const formSchema = z.object({
  title: z
    .string()
    .min(1, {
      message: 'Title is required',
    })
    .max(50, {
      message: 'Title must be less than 50 characters',
    }),
  body: z
    .string()
    .min(1, {
      message: 'Body is required',
    })
    .max(500, {
      message: 'Body must be less than 500 characters',
    }),
});
```

now we can use this schema to validate the form data before submitting the form.

```ts
export async function createTodo(formData: FormData) {
  const validatedFields = formSchema.safeParse({
    title: formData.get('title'),
    body: formData.get('body'),
  });

  // this will validate the fields based on the schema
  if (!validatedFields.success) {
    // flatten the error object defined by zod
    const errors = validatedFields.error.flatten().fieldErrors;
    return {
      success: false,
      // add the new errors object to the returned object
      errors,
    };
  }

  // same as before
}
```

this server action now returns an object with the **success** boolean and the **errors** object if the form validation fails. this errors object has the following shape:

```ts
const errors: {
  title?: string[] | undefined;
  body?: string[] | undefined;
};
```

notice how the type of each field is an array of strings, this is because each field could have multiple errors. although in our case, we only have one error per field, either it's required or it's too long.

now let's update the client component to show the error messages.

```tsx
export default function Form() {
  const { pending } = useFormStatus();
  const [error, setError] = useState<string | null>(null);
  const [titleError, setTitleError] = useState<string[] | null>(null);
  const [bodyError, setBodyError] = useState<string[] | null>(null);

  async function handleSubmit(formData: FormData) {
    const result = await createTodo(formData);

    if (!result.success) {
      setError(result.message ?? null);

      if (result.errors?.title) {
        setTitleError(result.errors.title);
      }

      if (result.errors?.body) {
        setBodyError(result.errors.body);
      }
    } else {
      setError(null);
    }
  }

  return (
    <form action={handleSubmit}>
      <input name="title" type="text" />
      {titleError && <p>{titleError.join(', ')}</p>}

      <input name="body" type="text" disabled={pending} />
      {bodyError && <p>{bodyError.join(', ')}</p>}

      <button type="submit" disabled={pending}>
        {pending ? 'Submitting...' : 'Submit'}
      </button>
      {error && <p>{error}</p>}
    </form>
  );
}
```

this is already a good setup for form validation, but we still have to manually set the error state for each field. imagine if we have more fields. this is where **useActionState** comes in.

## form validation with useActionState

[useActionState](https://react.dev/reference/react/useActionState) is a hook that allows you to update state based on the result of a form action. that's what the official docs says, let's see it in practice.

first, let's see our previous code without **useActionState**. we're going to focus on the form component.

```tsx
export default function Form() {
  const { pending } = useFormStatus();
  const [error, setError] = useState<string | null>(null);
  const [titleError, setTitleError] = useState<string[] | null>(null);
  const [bodyError, setBodyError] = useState<string[] | null>(null);

  async function handleSubmit(formData: FormData) {
    const result = await createTodo(formData);

    if (!result.success) {
      setError(result.message ?? null);

      if (result.errors?.title) {
        setTitleError(result.errors.title);
      }

      if (result.errors?.body) {
        setBodyError(result.errors.body);
      }
    } else {
      setError(null);
    }
  }

  return (
    <form action={handleSubmit}>
      <input name="title" type="text" />
      {titleError && <p>{titleError.join(', ')}</p>}

      <input name="body" type="text" disabled={pending} />
      {bodyError && <p>{bodyError.join(', ')}</p>}

      <button type="submit" disabled={pending}>
        {pending ? 'Submitting...' : 'Submit'}
      </button>
      {error && <p>{error}</p>}
    </form>
  );
}
```

we handle each state manually, **giving each field its own error state**. 

here's how we can simplify this with **useActionState**:

```tsx
import { useActionState } from 'react';
//...

const initialState = {
  success: false,
  errors: {
    title: [],
    body: [],
  },
};

export default function Form() {
  const { pending } = useFormStatus();
  const [state, formAction] = useActionState(createTodo, initialState);

  return (
    <form action={formAction}>
      <Label htmlFor="title">Title</Label>
      <Input name="title" type="text" />
      {state.errors?.title && <p>{state.errors.title}</p>}

      <Label htmlFor="body">Body</Label>
      <Input name="body" type="text" disabled={pending} />
      {state.errors?.body && <p>{state.errors.body}</p>}

      <Button type="submit" disabled={pending}>
        {pending ? 'Submitting...' : 'Submit'}
      </Button>

      <p>{state.message}</p>
    </form>
  );
}
```

and on the server action, we don't need to change anything, just add prevState to the function parameters.

```ts
export async function createTodo(prevState: any, formData: FormData) {
  //...
}
```

you can just use any type for the prevState, but it's better to define a type for it.

let's break down the changes:

- define an **initialState** object that has a **success** boolean and an **errors** object, this will be the **initial state** of the form.
```ts
const initialState = {
  success: false,
  errors: {
    title: [],
    body: [],
  },
};
```

- handle the form action with **useActionState**. this hook takes the server action and the initial state as parameters, and will return the current state and the form action as value.
```tsx
const [state, formAction] = useActionState(createTodo, initialState);
```

- show the error message for each field using **state.errors**.
```tsx
{state.errors?.title && <p>{state.errors.title}</p>}
{state.errors?.body && <p>{state.errors.body}</p>}
```

- show the message returned from the server action.
```tsx
<p>{state.message}</p>
```

now, instead of manually setting the error state for each field, we can use **useActionState** to handle the form action and **update the state based on the form result**.

that's basically it! you can now validate your forms with **useActionState** and **zod**. this will make your form validation code cleaner and easier to maintain.

oh and a bit of extra, useActionState returns another value called **pending** that you can use to disable the submit button while the form is submitting.

```tsx
export default function Form() {
  const [state, formAction, pending] = useActionState(createTodo, initialState);

  //...

  return (
    <form action={formAction}>
      {/* ... */}

      <button type="submit" disabled={pending}>
        {pending ? 'Submitting...' : 'Submit'}
      </button>

      {/* ... */}
    </form>
  );
}
```

this will disable the submit button while the form is submitting, and show a "Submitting..." text on the button, just like what we did before with **useFormStatus**. but now, it's more integrated with the form action.

## conclusion

to recap, we've learned how to validate forms on the server with **zod** and return a **state object** from the server action, this lets us **show the error message for each field** using react useState. then we learned how to simplify the form validation code with **useActionState**, this will handle the form action and update the state based on the result instead of setting the state for each indiviual field manually.

**useActionState** is one of the most prominent feature of the upcoming react 19, and it will make form validation easier and more integrated with the form action. it's a great addition to the react ecosystem.

note that this feature is still experimental and shouldn't really be used in production yet. but it's a good idea to learn it and see how it can simplify your form validation code.

if you've made it this far, thank you for reading! i hope you find this post helpful. if you have any questions or feedback, feel free to leave a comment below. happy coding!

## references

- [next.js server-side form validation](https://nextjs.org/docs/app/building-your-application/data-fetching/server-actions-and-mutations#server-side-form-validation)
- [useActionState](https://react.dev/reference/react/useActionState)
- [useFormStatus](https://react.dev/reference/react-dom/hooks/useFormStatus)
- [zod](https://github.com/colinhacks/zod)
